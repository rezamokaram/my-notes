# üß© Uber Fx ‚Äî `fx.As` Complete Guide

## üí° What Is `fx.As`?

`fx.As` tells Fx to register a provided value **as an interface type** instead of its concrete type.

Normally, when you use `fx.Provide`, Fx registers **the exact type** returned by your constructor.
Sometimes, you want to tell Fx: ‚Äúthis object implements an interface, register it as that interface.‚Äù

That‚Äôs what `fx.As()` does.

---

## ‚öôÔ∏è Example Without `fx.As`

```go
type Storage interface {
    Save(data string)
}

type FileStorage struct{}

func (f *FileStorage) Save(data string) {
    fmt.Println("Saving to file:", data)
}

func NewFileStorage() *FileStorage {
    return &FileStorage{}
}

func NewService(s Storage) {
    s.Save("hello")
}

func main() {
    app := fx.New(
        fx.Provide(NewFileStorage),
        fx.Invoke(NewService),
    )
    app.Run()
}
```

üö® **Fails!** Because `fx.Provide(NewFileStorage)` provides `*FileStorage`, but `NewService` expects `Storage` interface.

---

## ‚úÖ Fixing It with `fx.As`

```go
app := fx.New(
    fx.Provide(
        fx.Annotate(
            NewFileStorage,
            fx.As(new(Storage)),
        ),
    ),
    fx.Invoke(NewService),
)
```

‚úÖ Works!
Fx now knows to register `NewFileStorage()`‚Äôs return value **as `Storage`**.

---

## üß† How It Works

| Default                       | With `fx.As()`                |
| ----------------------------- | ----------------------------- |
| Registers `*FileStorage` type | Registers `Storage` interface |

So any function requiring `Storage` will now receive that same instance.

---

## üß© Multiple Interfaces

You can register a single struct as multiple interfaces:

```go
fx.Provide(
    fx.Annotate(
        NewFileStorage,
        fx.As(new(Storage), new(io.Writer)),
    ),
)
```

This means Fx will register `NewFileStorage()` both as `Storage` and `io.Writer`.

---

## üß± Example ‚Äî Groups with `fx.As`

```go
type Storage interface {
    Save(data string)
}

type MemoryStorage struct{}
func (m *MemoryStorage) Save(data string) { fmt.Println("mem:", data) }

type FileStorage struct{}
func (f *FileStorage) Save(data string) { fmt.Println("file:", data) }

func main() {
    app := fx.New(
        fx.Provide(
            fx.Annotate(NewMemoryStorage, fx.As(new(Storage)), fx.ResultTags(`group:"storages"`)),
            fx.Annotate(NewFileStorage, fx.As(new(Storage)), fx.ResultTags(`group:"storages"`)),
        ),
        fx.Invoke(func(storages []Storage) {
            for _, s := range storages {
                s.Save("data")
            }
        }),
    )
    app.Run()
}
```

‚úÖ Both `MemoryStorage` and `FileStorage` are registered as `Storage` implementations under the `storages` group.

---

## ‚öôÔ∏è Example ‚Äî Named Interface Bindings

```go
fx.Provide(
    fx.Annotate(
        NewFileStorage,
        fx.As(new(Storage)),
        fx.ResultTags(`name:"fileStorage"`),
    ),
)
```

Then consume it as:

```go
type Params struct {
    fx.In
    File Storage `name:"fileStorage"`
}
```

---

## üß© Why `fx.As` Exists

Without `fx.As`, you‚Äôd have to wrap your constructor manually:

```go
func NewStorage() Storage {
    return &FileStorage{}
}
```

But this loses access to `*FileStorage` if you ever need it directly.

‚úÖ With `fx.As`, you keep your constructor returning a concrete type but register it as an interface.

---

## ‚úÖ Summary

| Concept                  | Description                  | Example                                   |
| ------------------------ | ---------------------------- | ----------------------------------------- |
| **`fx.As()`**            | Registers value as interface | `fx.As(new(Storage))`                     |
| **`fx.Annotate()`**      | Adds metadata to constructor | `fx.Annotate(NewDB, fx.As(new(Storage)))` |
| **Combine with `group`** | Multiple implementations     | `fx.ResultTags('group:"storages"')`       |
| **Combine with `name`**  | Named instance               | `fx.ResultTags('name:"main"')`            |

---

## üß© TL;DR

| Scenario                            | Use                 |
| ----------------------------------- | ------------------- |
| Struct implements an interface      | `fx.As()`           |
| Multiple implementations in a group | `fx.As()` + `group` |
| Named interface binding             | `fx.As()` + `name`  |
| Keep returning concrete type        | `fx.As()`           |

---

**‚úÖ Use `fx.As`** when you want Fx to register a concrete type **as an interface**.
It‚Äôs clean, explicit, and avoids wrapping constructors unnecessarily.
